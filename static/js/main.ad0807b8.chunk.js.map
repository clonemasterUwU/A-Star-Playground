{"version":3,"sources":["components/Node.jsx","algorithms/PriorityQueue.js","algorithms/Astar.js","components/Board.jsx","components/Tooltip.jsx","components/Playground.jsx","components/Chapter0/Screen00.jsx","components/Chapter0/Screen01.jsx","components/Chapter0/Chapter0.jsx","components/Stage31.jsx","components/Navigation.jsx","components/Main.jsx","fonts/FuturaHandwritten.ttf","fonts/theme.js","fonts/fonts.js","App.js","reportWebVitals.js","index.js"],"names":["Node","props","onRightClick","nodeInfo","row","col","status","weight","isPath","onMouseUp","onMouseDown","onMouseEnter","StyleNode","onContextMenu","event","styled","td","parent","i","left","right","PriorityQueue","comparator","a","b","this","_heap","_comparator","length","size","values","forEach","value","push","_siftUp","poppedValue","peek","bottom","_swap","pop","_siftDown","replacedValue","j","node","_greater","maxChild","pathTo","curr","path","unshift","_reset","board","start","end","f","g","h","isWall","visited","closed","r","c","mahattan","Math","abs","d4","square4","res","dr","dc","Board","boardSize","heuristic","setStart","useState","setBoard","mousePress","setMousePress","nodePress","setNodePress","useEffect","gridGenerator","neighbor","newBoard","slice","pq","console","log","nextNode","search","rightClick","preventDefault","buttons","wallToggle","weightChange","moveSpecialNode","map","rid","className","nid","prevRow","prevCol","newRow","newCol","grid","nodeGenerator","oldNode","Tooltip","setBoardSize","setHeuristic","RowSlider","aria-label","max","min","marks","step","onChange","valueLabelDisplay","component","Button","variant","onClick","Slider","Playground","Screen00","setChapterStage","Wrapper","IntroText","fontSize","color","div","h1","Screen01","Chapter0","chapterStage","Stage31","Navigation","stage","setStage","StyleDiv","StyledTooltip","title","Fab","Main","FontFormat","theme","FuturaHandwritten","createMuiTheme","typography","fontFamily","join","createGlobalStyle","App","ThemeProvider","CssBaseline","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.ad0807b8.chunk.js","sourcesContent":["\nimport styled  from 'styled-components';\n\nexport default function Node(props){\n  const { onRightClick,nodeInfo:{row,col,status,weight,isPath}, onMouseUp, onMouseDown, onMouseEnter } = props;\nreturn(\n  <StyleNode\n    row={row}\n    col={col}\n    weight={weight}\n    status={status}\n    isPath={isPath}\n    onContextMenu = {(event)=>onRightClick(event,row,col)} \n    onMouseDown={(event)=>onMouseDown(event,row,col)}\n    onMouseUp={(event)=>onMouseUp(event,row,col)}\n    onMouseEnter={(event)=>onMouseEnter(event,row,col)}\n  />\n    \n)\n}\nconst StyleNode = styled.td`\n  width: 25px;\n  height: 25px;\n  border: 1px solid rgb(175, 216, 248);  \n  background-color: ${props=>props.status===1?`rgb(248, 131, 131)`\n                            :props.status===2?`rgb(129, 127, 252)`\n                            :props.isPath===true?`rgb(219, 241, 70)`\n                            :props.status===0?`hsl(0,0%,${(15-props.weight)*100/16}%)`\n                            :\"\"};\n`;\n","const top = 0;\nconst parent = i => ((i + 1) >>> 1) - 1;\nconst left = i => (i << 1) + 1;\nconst right = i => (i + 1) << 1;\n\nexport default class PriorityQueue {\n  constructor(comparator = (a, b) => a > b) {\n    this._heap = [];\n    this._comparator = comparator;\n  }\n  size() {\n    return this._heap.length;\n  }\n  isEmpty() {\n    return this.size() === 0;\n  }\n  peek() {\n    return this._heap[top];\n  }\n  push(...values) {\n    values.forEach(value => {\n      this._heap.push(value);\n      this._siftUp();\n    });\n    return this.size();\n  }\n  pop() {\n    const poppedValue = this.peek();\n    const bottom = this.size() - 1;\n    if (bottom > top) {\n      this._swap(top, bottom);\n    }\n    this._heap.pop();\n    this._siftDown();\n    return poppedValue;\n  }\n  replace(value) {\n    const replacedValue = this.peek();\n    this._heap[top] = value;\n    this._siftDown();\n    return replacedValue;\n  }\n  _greater(i, j) {\n    return this._comparator(this._heap[i], this._heap[j]);\n  }\n  _swap(i, j) {\n    [this._heap[i], this._heap[j]] = [this._heap[j], this._heap[i]];\n  }\n  _siftUp() {\n    let node = this.size() - 1;\n    while (node > top && this._greater(node, parent(node))) {\n      this._swap(node, parent(node));\n      node = parent(node);\n    }\n  }\n  _siftDown() {\n    let node = top;\n    while (\n      (left(node) < this.size() && this._greater(left(node), node)) ||\n      (right(node) < this.size() && this._greater(right(node), node))\n    ) {\n      let maxChild = (right(node) < this.size() && this._greater(right(node), left(node))) ? right(node) : left(node);\n      this._swap(node, maxChild);\n      node = maxChild;\n    }\n  }\n}","// javascript-astar 0.4.1\n// http://github.com/bgrins/javascript-astar\n// Freely distributable under the MIT License.\n// Implements the astar search algorithm in javascript using a Binary Heap.\n// Includes Binary Heap (with modifications) from Marijn Haverbeke.\n// http://eloquentjavascript.net/appendix2.html\nimport PriorityQueue from './PriorityQueue'\nfunction pathTo(node) {\n  var curr = node;\n  var path = [];\n  while (curr.parent) {\n    path.unshift(curr);\n    curr = curr.parent;\n  }\n  return path;\n}\n\nfunction getHeap() {\n  return new BinaryHeap(function(node) {\n    return node.f;\n  });\n}\n\nvar astar = {\n  /**\n  * Perform an A* Search on a graph given a start and end node.\n  * @param {Graph} graph\n  * @param {GridNode} start\n  * @param {GridNode} end\n  * @param {Object} [options]\n  * @param {bool} [options.closest] Specifies whether to return the\n             path to the closest node if the target is unreachable.\n  * @param {Function} [options.heuristic] Heuristic function (see\n  *          astar.heuristics).\n  */\n  search: function(graph, start, end, options) {\n    graph.cleanDirty();\n    options = options || {};\n    var heuristic = options.heuristic || astar.heuristics.manhattan;\n    var closest = options.closest || false;\n\n    var openHeap = getHeap();\n    var closestNode = start; // set the start node to be the closest if required\n    start.h = heuristic(start, end);\n    graph.markDirty(start);\n\n    openHeap.push(start);\n\n    while (openHeap.size() > 0) {\n\n      // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.\n      var currentNode = openHeap.pop();\n\n      // End case -- result has been found, return the traced path.\n      if (currentNode === end) {\n        return pathTo(currentNode);\n      }\n\n      // Normal case -- move currentNode from open to closed, process each of its neighbors.\n      currentNode.closed = true;\n\n      // Find all neighbors for the current node.\n      var neighbors = graph.neighbors(currentNode);\n\n      for (var i = 0, il = neighbors.length; i < il; ++i) {\n        var neighbor = neighbors[i];\n\n        if (neighbor.closed || neighbor.isWall()) {\n          // Not a valid node to process, skip to next neighbor.\n          continue;\n        }\n\n        // The g score is the shortest distance from start to current node.\n        // We need to check if the path we have arrived at this neighbor is the shortest one we have seen yet.\n        var gScore = currentNode.g + neighbor.getCost(currentNode);\n        var beenVisited = neighbor.visited;\n\n        if (!beenVisited || gScore < neighbor.g) {\n\n          // Found an optimal (so far) path to this node.  Take score for node to see how good it is.\n          neighbor.visited = true;\n          neighbor.parent = currentNode;\n          neighbor.h = neighbor.h || heuristic(neighbor, end);\n          neighbor.g = gScore;\n          neighbor.f = neighbor.g + neighbor.h;\n          graph.markDirty(neighbor);\n          if (closest) {\n            // If the neighbour is closer than the current closestNode or if it's equally close but has\n            // a cheaper path than the current closest node then it becomes the closest node\n            if (neighbor.h < closestNode.h || (neighbor.h === closestNode.h && neighbor.g < closestNode.g)) {\n              closestNode = neighbor;\n            }\n          }\n\n          if (!beenVisited) {\n            // Pushing to heap will put it in proper place based on the 'f' value.\n            openHeap.push(neighbor);\n          } else {\n            // Already seen the node, but since it has been rescored we need to reorder it in the heap\n            openHeap.rescoreElement(neighbor);\n          }\n        }\n      }\n    }\n\n    if (closest) {\n      return pathTo(closestNode);\n    }\n\n    // No result was found - empty array signifies failure to find path.\n    return [];\n  },\n  // See list of heuristics: http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html\n  heuristics: {\n    manhattan: function(pos0, pos1) {\n      var d1 = Math.abs(pos1.x - pos0.x);\n      var d2 = Math.abs(pos1.y - pos0.y);\n      return d1 + d2;\n    },\n    diagonal: function(pos0, pos1) {\n      var D = 1;\n      var D2 = Math.sqrt(2);\n      var d1 = Math.abs(pos1.x - pos0.x);\n      var d2 = Math.abs(pos1.y - pos0.y);\n      return (D * (d1 + d2)) + ((D2 - (2 * D)) * Math.min(d1, d2));\n    }\n  },\n  cleanNode: function(node) {\n    node.f = 0;\n    node.g = 0;\n    node.h = 0;\n    node.visited = false;\n    node.closed = false;\n    node.parent = null;\n  }\n};\n\n/**\n * A graph memory structure\n * @param {Array} gridIn 2D array of input weights\n * @param {Object} [options]\n * @param {bool} [options.diagonal] Specifies whether diagonal moves are allowed\n */\nclass Graph {\n  constructor(gridIn, options) {\n    options = options || {};\n    this.nodes = [];\n    this.diagonal = !!options.diagonal;\n    this.grid = [];\n    this.start = null;\n    this.end = null;\n    for (var x = 0; x < gridIn.length; x++) {\n      this.grid[x] = [];\n\n      for (var y = 0, row = gridIn[x]; y < row.length; y++) {\n        var node = new GridNode(x, y, gridIn[x][y].weight);\n        this.grid[x][y] = node;\n        this.nodes.push(node);\n        if (gridIn[x][y].status === 1)\n          this.start = node;\n        if (gridIn[x][y].status === 2)\n          this.end = node;\n      }\n    }\n    this.init();\n  }\n  init() {\n    this.dirtyNodes = [];\n    for (var i = 0; i < this.nodes.length; i++) {\n      astar.cleanNode(this.nodes[i]);\n    }\n  }\n  cleanDirty() {\n    for (var i = 0; i < this.dirtyNodes.length; i++) {\n      astar.cleanNode(this.dirtyNodes[i]);\n    }\n    this.dirtyNodes = [];\n  }\n  markDirty(node) {\n    this.dirtyNodes.push(node);\n  }\n  neighbors(node) {\n    var ret = [];\n    var x = node.x;\n    var y = node.y;\n    var grid = this.grid;\n\n    // West\n    if (grid[x - 1] && grid[x - 1][y]) {\n      ret.push(grid[x - 1][y]);\n    }\n\n    // East\n    if (grid[x + 1] && grid[x + 1][y]) {\n      ret.push(grid[x + 1][y]);\n    }\n\n    // South\n    if (grid[x] && grid[x][y - 1]) {\n      ret.push(grid[x][y - 1]);\n    }\n\n    // North\n    if (grid[x] && grid[x][y + 1]) {\n      ret.push(grid[x][y + 1]);\n    }\n\n    if (this.diagonal) {\n      // Southwest\n      if (grid[x - 1] && grid[x - 1][y - 1]) {\n        ret.push(grid[x - 1][y - 1]);\n      }\n\n      // Southeast\n      if (grid[x + 1] && grid[x + 1][y - 1]) {\n        ret.push(grid[x + 1][y - 1]);\n      }\n\n      // Northwest\n      if (grid[x - 1] && grid[x - 1][y + 1]) {\n        ret.push(grid[x - 1][y + 1]);\n      }\n\n      // Northeast\n      if (grid[x + 1] && grid[x + 1][y + 1]) {\n        ret.push(grid[x + 1][y + 1]);\n      }\n    }\n\n    return ret;\n  }\n  toString() {\n    var graphString = [];\n    var nodes = this.grid;\n    for (var x = 0; x < nodes.length; x++) {\n      var rowDebug = [];\n      var row = nodes[x];\n      for (var y = 0; y < row.length; y++) {\n        rowDebug.push(row[y].weight);\n      }\n      graphString.push(rowDebug.join(\" \"));\n    }\n    return graphString.join(\"\\n\");\n  }\n}\n\n\n\n\n\n\nclass GridNode {\n  constructor(x, y, weight) {\n    this.x = x;\n    this.y = y;\n    this.weight = weight;\n  }\n  toString() {\n    return \"[\" + this.x + \" \" + this.y + \"]\";\n  }\n  getCost(fromNeighbor) {\n    // Take diagonal weight into consideration.\n    if (fromNeighbor && fromNeighbor.x !== this.x && fromNeighbor.y !== this.y) {\n      return this.weight * 1.41421;\n    }\n    return this.weight;\n  }\n  isWall() {\n    return this.weight === 15\n  }\n}\n\n\n\n\nclass BinaryHeap {\n  constructor(scoreFunction) {\n    this.content = [];\n    this.scoreFunction = scoreFunction;\n  }\n  push(element) {\n    // Add the new element to the end of the array.\n    this.content.push(element);\n\n    // Allow it to sink down.\n    this.sinkDown(this.content.length - 1);\n  }\n  pop() {\n    // Store the first element so we can return it later.\n    var result = this.content[0];\n    // Get the element at the end of the array.\n    var end = this.content.pop();\n    // If there are any elements left, put the end element at the\n    // start, and let it bubble up.\n    if (this.content.length > 0) {\n      this.content[0] = end;\n      this.bubbleUp(0);\n    }\n    return result;\n  }\n  remove(node) {\n    var i = this.content.indexOf(node);\n\n    // When it is found, the process seen in 'pop' is repeated\n    // to fill up the hole.\n    var end = this.content.pop();\n\n    if (i !== this.content.length - 1) {\n      this.content[i] = end;\n\n      if (this.scoreFunction(end) < this.scoreFunction(node)) {\n        this.sinkDown(i);\n      } else {\n        this.bubbleUp(i);\n      }\n    }\n  }\n  size() {\n    return this.content.length;\n  }\n  rescoreElement(node) {\n    this.sinkDown(this.content.indexOf(node));\n  }\n  sinkDown(n) {\n    // Fetch the element that has to be sunk.\n    var element = this.content[n];\n\n    // When at 0, an element can not sink any further.\n    while (n > 0) {\n\n      // Compute the parent element's index, and fetch it.\n      var parentN = ((n + 1) >> 1) - 1;\n      var parent = this.content[parentN];\n      // Swap the elements if the parent is greater.\n      if (this.scoreFunction(element) < this.scoreFunction(parent)) {\n        this.content[parentN] = element;\n        this.content[n] = parent;\n        // Update 'n' to continue at the new position.\n        n = parentN;\n      }\n\n      // Found a parent that is less, no need to sink any further.\n      else {\n        break;\n      }\n    }\n  }\n  bubbleUp(n) {\n    // Look up the target element and its score.\n    var length = this.content.length;\n    var element = this.content[n];\n    var elemScore = this.scoreFunction(element);\n\n    while (true) {\n      // Compute the indices of the child elements.\n      var child2N = (n + 1) << 1;\n      var child1N = child2N - 1;\n      // This is used to store the new position of the element, if any.\n      var swap = null;\n      var child1Score;\n      // If the first child exists (is inside the array)...\n      if (child1N < length) {\n        // Look it up and compute its score.\n        var child1 = this.content[child1N];\n        child1Score = this.scoreFunction(child1);\n\n        // If the score is less than our element's, we need to swap.\n        if (child1Score < elemScore) {\n          swap = child1N;\n        }\n      }\n\n      // Do the same checks for the other child.\n      if (child2N < length) {\n        var child2 = this.content[child2N];\n        var child2Score = this.scoreFunction(child2);\n        if (child2Score < (swap === null ? elemScore : child1Score)) {\n          swap = child2N;\n        }\n      }\n\n      // If the element needs to be moved, swap it, and continue.\n      if (swap !== null) {\n        this.content[n] = this.content[swap];\n        this.content[swap] = element;\n        n = swap;\n      }\n\n      // Otherwise, we are done.\n      else {\n        break;\n      }\n    }\n  }\n}\n\n\nconst _reset=(board)=>{\n  let start,end;\n  for(let i=0;i<board.length;i++){\n    for(let j=0;j<board[0].length;j++){\n      board[i][j].f = 0;\n      board[i][j].g = 0;\n      board[i][j].h = 0;\n      board[i][j].isWall = board[i][j].weight === 15;\n      board[i][j].visited = false;\n      board[i][j].closed = false;\n      board[i][j].parent = null;\n      board[i][j].r = i;\n      board[i][j].c = j;\n      board[i][j].isPath = false;\n      if(board[i][j].status===1) start=board[i][j];\n      if(board[i][j].status===2) end=board[i][j];\n    }\n  }\n  return {start,end};\n};\nconst mahattan = (a,b)=>{\n  return Math.abs(a.r-b.r)+Math.abs(a.c-b.c);\n}\nconst d4 = [-1,0,1,0,-1];\nconst square4 = (node,board)=>{\n  const res = [];\n  for(let i=0;i<4;i++){\n    const dr = node.r + d4[i];\n    const dc = node.c + d4[i+1];\n    if(dr>=0&&dc>=0&&dr<board.length&&dc<board[0].length) res.push(board[dr][dc]);\n  }\n  return res;\n}\nconst search=(board,heuristic=mahattan,neighbor=square4)=>{\n  const newBoard = board.slice();\n  const pq = new PriorityQueue((a,b)=>a.f<b.f);\n  const {start,end} = _reset(newBoard);\n  start.h=heuristic(start,end);\n  start.f=start.h;\n  // console.log(newBoard)\n  pq.push({r:start.r,c:start.c,f:start.h});\n  while(pq.size()>0){\n    const {r,c,f} = pq.pop();\n    console.log(r,c,f);\n    const nextNode = newBoard[r][c]; // nextNode: {r,c,f}\n    if(nextNode===end){\n      pathTo(nextNode).forEach((node)=>node.isPath=true);\n      return newBoard;\n    } \n    if(!nextNode.closed){\n      nextNode.closed=true;\n      neighbor(nextNode,newBoard).forEach((node)=>{\n        if(!node.closed && !node.isWall){\n          if(node.visited && nextNode.g + node.weight < node.g){\n            node.parent = nextNode;\n            node.g = nextNode.g + nextNode.weight;\n            node.f = node.g + node.h;\n            pq.push({r:node.r,c:node.c,f:node.f});\n          } else if(!node.visited){\n            node.parent=nextNode;\n            node.g = nextNode.g + node.weight;\n            node.h = heuristic(node,end);\n            node.visited = true;\n            node.f = node.g + node.h;\n            pq.push({r:node.r,c:node.c,f:node.f});\n          }\n        }\n      })\n    }\n    \n  }\n  return newBoard;\n}\n\n\nexport {astar as default, Graph, search}\n","import {useEffect, useState} from 'react';\nimport Node from './Node';\n\nimport aStar,{Graph,search} from '../algorithms/Astar';\nimport \"./Board.css\";\nexport default function Board(props){\n  const {boardSize,heuristic,start,setStart} = props;\n  const [board,setBoard] = useState([]);\n  const [mousePress,setMousePress] =  useState(0);\n  let [nodePress,setNodePress] = useState(null);\n  useEffect(()=>{\n    setBoard(gridGenerator(boardSize[0],boardSize[1]));\n  },[boardSize]);\n  useEffect(()=>{\n    if(start){\n      setBoard(search(board));\n      setStart(false);\n    }\n  },[start,board]);\n  const rightClick=(event,row,col)=>{\n    event.preventDefault();\n    // setBoard(wallToggle(board,row,col));\n  }\n  const onMouseDown = (event,row, col) => {\n    event.preventDefault();\n    if(board[row][col].status!==0){//special node\n      setNodePress ([row,col]);\n      setMousePress(event.buttons);\n    } else {\n      switch(event.buttons){\n        case 2://leftmouse press\n          setMousePress(2);\n          setBoard(wallToggle(board,row,col));\n          break;\n        case 1://rightmouse press\n          setMousePress(1);\n          setBoard(weightChange(board,row,col));\n          break;\n        default:\n      }  \n    }\n    setStart(true);\n      \n  }\n\n  const onMouseEnter = (event,row, col) => {\n    event.preventDefault();\n    if(nodePress!==null){ //special node\n      if(board[row][col].status===0&&mousePress!==0){\n        setBoard(moveSpecialNode(board,nodePress[0],nodePress[1],row,col));\n        setNodePress([row,col]);\n        setStart(true);\n      }\n    }else if (mousePress===2){\n      setBoard(wallToggle(board,row,col));\n      setStart(true);\n    } else if(mousePress===1){\n      setBoard(weightChange(board,row,col));\n      setStart(true);\n    }\n  }\n\n  const onMouseUp = (event) => {\n    event.preventDefault();\n    setMousePress(0);\n    setNodePress(null);\n  }\n\n  return (\n    <table>\n    <tbody>\n    {board.map((row,rid)=>{\n      return (\n        <tr key={rid} className=\"row\">\n          {row.map((node,nid)=>{\n            return(\n              <Node\n                key={nid}\n                nodeInfo={node}\n                onRightClick={rightClick}\n                onMouseDown={onMouseDown}\n                onMouseEnter={onMouseEnter}\n                onMouseUp={onMouseUp}\n              />\n            ) \n          })}\n        </tr>\n      )\n    })\n    }\n    </tbody>\n    </table>\n  )\n  \n}\n\nconst moveSpecialNode = (board,prevRow,prevCol,newRow,newCol) => {\n  const newBoard = board.slice();\n  const status = board[prevRow][prevCol].status;\n  newBoard[prevRow][prevCol] = {\n    ...board[prevRow][prevCol],\n    status:0,\n  }\n  newBoard[newRow][newCol] = {\n    ...board[newRow][newCol],\n    status:status,\n  }\n  return newBoard;\n}\nconst gridGenerator = (row,col) => {\n  const grid = [];\n  for(let i=0;i<row;i++){\n    const row = [];\n    for(let j=0;j<col;j++){\n      row.push(nodeGenerator(i,j));\n    }\n    grid.push(row);\n  }\n  grid[0][0].status=1;\n  grid[grid.length-1][grid[0].length-1].status=2;\n  return grid;\n}\n/*\nnode status:\n0: normal\n1: start\n2: end\n3: side-quest\n\n*/\nconst nodeGenerator = (row,col) => {\n  return {\n    row,col,\n    weight:1,\n    status:0,\n  }\n}\n\nconst weightChange = (board,row,col) => {\n  const newBoard = board.slice();\n  const oldNode = newBoard[row][col];\n  newBoard[row][col] = {\n    ...oldNode,\n    weight: (oldNode.weight+1)%16,\n  }\n  return newBoard;\n}\n\nconst wallToggle = (board,row,col) => {\n  const newBoard = board.slice();\n  const oldNode = newBoard[row][col];\n  newBoard[row][col] = {\n    ...oldNode,\n    weight:oldNode.weight===15?1:15,\n  }\n  return newBoard;\n}\n\nconst getShortestPath = (board,start,end)=>{\n\n}\n\n","import { Button } from '@material-ui/core';\nimport Slider from '@material-ui/core/Slider'\nimport styled  from 'styled-components';\n\nexport default function Tooltip(props){\n  const {boardSize,setBoardSize,heuristic,setHeuristic,setStart} = props;\n  return(\n    <>\n    <RowSlider\n      aria-label=\"Column\"\n      max={20}\n      min={5}\n      marks\n      step={1}\n      value={boardSize[0]}\n      onChange={(event,value)=>setBoardSize([value,boardSize[1]])}\n      valueLabelDisplay=\"auto\"\n      component=\"span\"\n    />\n    <Button variant=\"contained\" onClick={()=>setStart(true)}>Start</Button>\n    <Button variant=\"contained\" onClick={()=>setBoardSize([...boardSize])}>Reset</Button>\n\n    </>\n  )\n}\nconst RowSlider = styled(Slider)`\n  width: 300px;\n`\n","import { useState } from \"react\";\nimport Board from \"./Board\";\nimport Tooltip from './Tooltip'\n\nexport default function Playground(){\n  const [boardSize,setBoardSize] = useState([15,15]);\n  const [heuristic,setHeuristic] = useState(\"manhattan\");\n  const [start,setStart] = useState(false);\n  return(\n    <>\n    <Tooltip\n      boardSize={boardSize} \n      setBoardSize={setBoardSize}\n      heuristic={heuristic}\n      setHeuristic={setHeuristic}\n      start={start}\n      setStart={setStart}\n\n    />\n    <Board\n      start={start}\n      setStart={setStart}\n      boardSize={boardSize}\n      heuristic={heuristic}\n    />\n    \n    </>\n  )\n}","import styled from \"styled-components\"\nimport Button from '@material-ui/core/Button'\nimport ArrowIcon from '@material-ui/icons/ArrowRightAlt'\nexport default function Screen00(props){\n  const {setChapterStage} = props;\n  return(\n    <Wrapper>\n    <IntroText>\n      A star\n      <br />\n      PLAYGROUND\n      \n    </IntroText>\n    <Button onClick={()=>setChapterStage(1)}>\n      <h1>Start</h1>\n      <ArrowIcon fontSize=\"large\" color=\"action\"/>\n    </Button>\n    </Wrapper>\n  )\n}\nconst Wrapper = styled.div`\n  display:flex;\n  flex-direction:column;\n  justify-content:center;\n`\n\nconst IntroText = styled.h1`\n  text-align:center;\n`","export default function Screen01(props){\n  return(\n  <div>\n    hi\n  </div>\n  )\n}","import {useState} from 'react'\nimport Screen00 from './Screen00'\nimport Screen01 from './Screen01'\nexport default function Chapter0(props){\n  const [chapterStage,setChapterStage] = useState(0);\n  switch(chapterStage){\n    case 0:\n      return (<Screen00 setChapterStage={setChapterStage}/>);  \n    case 1:\n      return (<Screen01 setChapterStage={setChapterStage}/>);  \n    default:\n      return null;\n  }\n}\n","export default function Stage31(){\n  return (\n    <div>\n      Pathfinding algorithms based on simple ideas: search around with minimal efforts until reaching the destiny. \n      <br></br>\n      A* stands out to be a “smart” one: it played the guessing game like a human. \n      <br></br>\n      This gives the algorithms some time advantages. \n      <br></br>\n      It calculates the value for each step by two components (f(x) = g(x) + h(x)): \n      <br></br>\n      the g(x) stands for the actual effort required to get to x-position. \n      <br></br>The h(x) stands for the estimation efforts required to go from x to the destination.\n\n    </div>\n  )\n}","\n/*\n<StyledNavigation value={stage} onChange={(event,value)=>setStage(value)}>\n      <BottomNavigationAction label=\"Recents\" value={0}  icon={<RestoreIcon />}/>\n      <BottomNavigationAction label=\"Favorites\" value={1} icon={<RestoreIcon />} />\n      <BottomNavigationAction label=\"Nearby\" value=\"nearby\"  />\n      <BottomNavigationAction label=\"Folder\" value=\"folder\" />\n    </StyledNavigation>\n*/\n\nimport Tooltip from \"@material-ui/core/Tooltip\";\nimport Fab from '@material-ui/core/Fab';\nimport styled from 'styled-components'\n\nexport default function Navigation(props){\n  const {stage,setStage} = props;\n  return (\n    <StyleDiv>\n      <StyledTooltip title=\"Chapter 0: Introduction\" onClick={()=>setStage(0)}>\n        <Fab color=\"primary\" size=\"small\">\n          0\n        </Fab>\n      </StyledTooltip>\n      <StyledTooltip title=\"Chapter 1: Pathfinding Algorithm\" onClick={()=>setStage(1)}>\n        <Fab color=\"primary\" size=\"small\">\n          1\n        </Fab>\n      </StyledTooltip>\n      <StyledTooltip title=\"Chapter 2: Heuristic\" onClick={()=>setStage(2)}>\n        <Fab color=\"primary\" size=\"small\">\n          2\n        </Fab>\n      </StyledTooltip>\n      <StyledTooltip title=\"Chapter 3: Breaking tie\" onClick={()=>setStage(3)}>\n        <Fab color=\"primary\" size=\"small\">\n          3\n        </Fab>\n      </StyledTooltip>\n      <StyledTooltip title=\"Chapter 4: Playground\" onClick={()=>setStage(4)}>\n        <Fab color=\"primary\" size=\"small\">\n          4\n        </Fab>\n      </StyledTooltip>\n    </StyleDiv>\n  )\n}\nconst StyledTooltip = styled(Tooltip)`\n  && {\n    margin: 8px;\n  }\n`\nconst StyleFab = styled(Fab)`\n`\nconst StyleDiv  = styled.div`\n  width:100%;\n  padding:12px;\n  background:#333;\n  position:absolute;\n  bottom:0;\n  justify-content:center;\n  display:flex;\n`","import {useState} from 'react'\nimport styled from 'styled-components'\nimport Playground from './Playground'\nimport Chapter0 from './Chapter0/Chapter0'\nimport Stage31 from './Stage31'\nimport Navigation from './Navigation'\nexport default function Main() {\n  const [stage,setStage] = useState(0);\n  return (\n    <FontFormat>\n    {\n      stage===0?<Chapter0 />\n      :stage===1?<Stage31 />\n      :stage===4?<Playground />\n      :null\n    }\n    <Navigation setStage={setStage}  stage={stage}/>\n    </FontFormat>\n\n  );\n}\nconst FontFormat = styled.div`\n  font-size:20px;\n  display:flex;\n  justify-content:center;\n  font-family:'Futura Handwritten';\n`\n\n","export default __webpack_public_path__ + \"static/media/FuturaHandwritten.dbaf4545.ttf\";","import FuturaHandwritten from './FuturaHandwritten.ttf';\nimport {createMuiTheme} from '@material-ui/core/styles'\nconst futuraHandwritten = {\n  fontFamily: \"FuturaHandwritten\",\n  fontStyle: 'normal',\n  fontDisplay: 'swap',\n  fontWeight: 400,\n  src:`url(${FuturaHandwritten}) format(truetype)`,\n  unicodeRange:'U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF',\n}\nconst theme = createMuiTheme({\n  typography: {\n    fontFamily: [\n      'Chilanka',\n      'cursive',\n    ].join(','),\n  },\n});\n//   overrides: {\n//     MuiCssBaseline: {\n//       '@global': {\n//         '@font-face': [futuraHandwritten],\n//       }\n//     }\n//   }\n// })\nexport default theme;","import { createGlobalStyle } from 'styled-components'\nimport FuturaHandwritten from './FuturaHandwritten.ttf'\nexport default createGlobalStyle`\n  @font-face {\n    font-family: 'Futura Handwritten';\n    src: url(${FuturaHandwritten}) format('truetype'),\n    local('Futura Handwritten');\n    font-weight: 300;\n    font-style: normal;\n  }\n`;","import { CssBaseline, ThemeProvider } from '@material-ui/core';\nimport Main from './components/Main'\nimport theme from './fonts/theme'\nimport GlobalFonts from './fonts/fonts'\n\nfunction App() {\n  return (\n    <ThemeProvider theme={theme}>\n      <CssBaseline />\n      <GlobalFonts />\n      <Main />\n    </ThemeProvider>  \n    \n  )\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}